**Выбранная архитектура: Вариант B (FastAPI + Redis Pub/Sub)**

---

**1. Технологический стек и обоснования**

* **FastAPI + Uvicorn** для WebSocket-сервера
  * Высокая производительность на базе asyncio
  * Простая декларативная работа с WS и готовая OpenAPI-документация

* **Redis Pub/Sub** для очередей сообщений
  * Мгновенная in-memory передача аудио-чанков и транскриптов
  * Горизонтальное масштабирование воркеров без изменений кода

* **BackgroundTasks** (или отдельный worker на asyncio) для фоновой обработки
  * Интегрируется в FastAPI без блокировок основного цикла
  * Позволяет гибко стартовать несколько параллельных процессов

* **Python 3.10+**
  * Современный синтаксис (match-case, расширенный typing)
  * Широкая экосистема асинхронных библиотек

* **Docker Compose** для локального окружения
  * Быстрый запуск и изоляция сервисов (приложение + Redis)
  * Единая команда для поднятия всей инфраструктуры


---

## 2. Основные функциональные требования

1. **WebSocket-сервер**
   * Принимает бинарные аудио-чанки от нескольких клиентов параллельно
   * Корректно обрабатывает подключения/отключения
   * Отправляет клиентам JSON-сообщения с транскриптами или ошибками

2. **Механизм очередей (IPC)**
   * Пересылка аудио-чанков от WS-сервера в фоновый воркер через Redis Pub/Sub
   * Поддержка множества параллельных клиентов без блокировок

3. **Фоновый обработчик аудио**
   * Запускается в одном или нескольких worker-процессах
   * Получает аудио-чанки из Redis, возвращает mock-транскрипты (фиксированная строка или простая имитация)
   * Публикует транскрипты обратно в отдельный канал Redis

4. **Обратная доставка результатов**
   * WS-сервер подписывается (“listen”) на канал транскриптов
   * По получении транскрипта оборачивает его в JSON и отправляет клиенту

5. **Нефункциональные требования**
   * Локальная работа, без внешних API
   * Время разработки — до 3 часов
   * Логирование ошибок и ключевых эвентов
   * Валидация входных данных (формат чанков, JSON)
   * Простая конфигурация (через `.env` или `config.yaml`)

---

## 3. Этапы работы

1. **Проектирование и подготовка окружения**
   * Определить Docker Compose с сервисами: application + Redis
   * Подготовить шаблон FastAPI-проекта

2. **Реализация WebSocket-сервера**
   * Создать endpoint `/ws`
   * Обработать подключение/отключение клиентов
   * Приём бинарных сообщений и публикация их в Redis (канал `audio_chunks`)

3. **Настройка Redis Pub/Sub**
   * Определить два канала: `audio_chunks` и `transcripts`
   * Настроить библиотеку `aioredis` или `redis-py` для асинхронного Pub/Sub

4. **Фоновый воркер для mock-транскрипции**
   * Подписка на `audio_chunks`
   * Приём чанков → генерация mock-транскрипта → публикация в `transcripts`

5. **Обратная доставка транскриптов**
   * WS-сервер подписывается на `transcripts`
   * По сообщениям из канала отправляет JSON клиентам

6. **Тестирование и отладка**
   * Юнит-тесты для Pub/Sub
   * Интеграционные тесты: эмуляция клиента WS
   * Проверка устойчивости при множестве подключений

7. **Документация и сборка**
   * README с инструкциями запуска через Docker Compose
   * Примеры запросов и ответов
   * Настройка переменных окружения

---

> **Дальнейшие шаги**
>
> 1. Открыть репозиторий, подготовить `docker-compose.yml` и базовый FastAPI-шаблон.
> 2. Реализовать WS-endpoint и связать его с каналом `audio_chunks`.
> 3. Параллельно приступить к воркеру для mock-обработки.
> 4. Интегрировать публикацию результатов и проверять end-to-end.
